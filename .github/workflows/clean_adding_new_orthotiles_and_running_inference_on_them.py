# -*- coding: utf-8 -*-
"""CLEAN adding new orthotiles and running inference on them.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TMxfUYpjncgar9By7HatIqjivp33w1Cc
"""
# This code will import a new orthomosaic, resample it to 10cm/pixel if needed, tile it to 1280 tile size,
    # run inference on the tiles, download the predictions folder to use later on roboflow, and save the 
    # predictions as geojson to visualize in QGIS

#-----------------------
#-----------------------
!pip install ultralytics rasterio shapely geopandas Pillow

import os
import math
import rasterio
from rasterio.windows import Window
import numpy as np
from ultralytics import YOLO
from shapely.geometry import box
import geopandas as gpd
from PIL import Image
from google.colab import files

# -----------------------
# 1. Upload trained model
# -----------------------
uploaded = files.upload()
model_path = [f for f in uploaded if f.endswith('.pt')][0]

# -----------------------
# Upload orthomosaic from Google Drive
# -----------------------
from google.colab import drive
drive.mount('/content/drive')
from google.colab import drive, files
tif_path = "/content/drive/MyDrive/Roberto, Sandoval/Clipped_Map1_ortho_export_SatJun28003757810473.tif"

# -----------------------
# 2. Load model
# -----------------------
model = YOLO(model_path)

# -----------------------
# 3. Check & resample orthomosaic to 10 cm if needed
# -----------------------
from rasterio.enums import Resampling
target_res = 0.10  # 10 cm = 0.10 m/pixel
resampled_tif = "resampled_input.tif"

with rasterio.open(tif_path) as src:
    xres, yres = src.res
    print(f"📏 Input resolution: {xres:.3f} m/px x {yres:.3f} m/px")

    if abs(xres - target_res) > 1e-3 or abs(yres - target_res) > 1e-3:
        print("⚡ Resampling to 10 cm/px ...")
        scale_x = xres / target_res
        scale_y = yres / target_res

        new_width = int(src.width * scale_x)
        new_height = int(src.height * scale_y)

        profile = src.profile
        profile.update({
            "width": new_width,
            "height": new_height,
            "transform": src.transform * src.transform.scale(
                src.width / new_width,
                src.height / new_height
            )
        })

        with rasterio.open(resampled_tif, "w", **profile) as dst:
            for b in range(1, src.count + 1):
                data = src.read(
                    b,
                    out_shape=(new_height, new_width),
                    resampling=Resampling.bilinear
                )
                dst.write(data, b)
        tif_path = resampled_tif
        print("✅ Resampled saved:", resampled_tif)
    else:
        print("✅ Already 10 cm/px, no resampling needed.")

# -----------------------
# 4. Tile orthomosaic
# -----------------------
tile_size = 1280
overlap = 128
tile_dir = "inference_tiles"
os.makedirs(tile_dir, exist_ok=True)

predictions = []

with rasterio.open(tif_path) as src:
    width, height = src.width, src.height
    transform = src.transform

    x_tiles = math.ceil(width / (tile_size - overlap))
    y_tiles = math.ceil(height / (tile_size - overlap))

    for i in range(x_tiles):
        for j in range(y_tiles):
            x = i * (tile_size - overlap)
            y = j * (tile_size - overlap)
            window = Window(x, y, tile_size, tile_size)

            # Read RGB
            tile = src.read([1,2,3], window=window, boundless=True, fill_value=0)
            tile = np.transpose(tile, (1,2,0))  # HWC

            # -----------------------
            # Skip completely black tiles
            # -----------------------
            if np.all(tile == 0):
                continue

            # Save temporary tile
            tile_path = os.path.join(tile_dir, f"tile_{i}_{j}.png")
            Image.fromarray(tile.astype(np.uint8)).save(tile_path)

# -----------------------
# 5. Run YOLO prediction
# -----------------------
results = model.predict(tile_path, imgsz=1024, conf=0.25, verbose=False)

import glob
import cv2

# -----------------------
# Output folders
# -----------------------
EXPORT_IMG_DIR = "/content/export_dataset_clean/images"
EXPORT_LBL_DIR = "/content/export_dataset_clean/labels"
os.makedirs(EXPORT_IMG_DIR, exist_ok=True)
os.makedirs(EXPORT_LBL_DIR, exist_ok=True)

# -----------------------
# Process all tiles
# -----------------------
tile_paths = sorted(glob.glob("inference_tiles/*"))  # works for .png, .jpg, .tif

for tile_path in tile_paths:
    # 1️⃣ Run YOLO prediction
    results = model.predict(
        source=tile_path,
        imgsz=1024,
        conf=0.25,
        verbose=False
    )

    # 2️⃣ Save clean image
    base_name = os.path.splitext(os.path.basename(tile_path))[0]
    img_outpath = os.path.join(EXPORT_IMG_DIR, base_name + ".jpg")

    img = cv2.imread(tile_path)
    cv2.imwrite(img_outpath, img)

    # 3️⃣ Save YOLO labels (.txt)
    lbl_outpath = os.path.join(EXPORT_LBL_DIR, base_name + ".txt")
    h, w = img.shape[:2]

    with open(lbl_outpath, "w") as f:
        for r in results:
            if r.boxes is None or len(r.boxes) == 0:
                continue

            xyxy = r.boxes.xyxy.cpu().numpy()
            clss  = r.boxes.cls.cpu().numpy().astype(int)

            for (x1, y1, x2, y2), cls_id in zip(xyxy, clss):
                x_center = ((x1 + x2) / 2) / w
                y_center = ((y1 + y2) / 2) / h
                box_w    = (x2 - x1) / w
                box_h    = (y2 - y1) / h

                f.write(f"{cls_id} {x_center:.6f} {y_center:.6f} {box_w:.6f} {box_h:.6f}\n")

# Zipping the predictions folder
!zip -r /content/yolo_predictions_dataset.zip /content/export_dataset_clean

# Downloading the predictions folder
from google.colab import files

files.download("/content/yolo_predictions_dataset.zip")

"""### Previewing Predictions"""

import cv2
import matplotlib.pyplot as plt
import numpy as np
from matplotlib.patches import Patch

# Generate distinct colors automatically
def generate_colors(num_classes):
    colors = []
    for i in range(num_classes):
        hue = i / num_classes
        r, g, b = [int(255 * x) for x in plt.cm.hsv(hue)[:3]]
        colors.append((b, g, r))  # BGR for OpenCV
    return colors

num_classes = len(model.names)
class_colors = generate_colors(num_classes)

def preview_detections(tile_path, results, save_path=None):
    """Preview detections on a single tile with class-specific colors, sharp Colab preview"""
    # Load image
    img = cv2.imread(tile_path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    img_with_boxes = img.copy()

    # Scale factors for text and line thickness
    scale = max(img.shape[:2]) / 1280
    line_thick = max(2, int(2 * scale))
    font_scale = max(0.7, 0.7 * scale)

    # Draw detections
    for r in results:
        if r.boxes is None or len(r.boxes) == 0:
            continue
        boxes = r.boxes.xyxy.cpu().numpy()
        confs = r.boxes.conf.cpu().numpy()
        clss = r.boxes.cls.cpu().numpy().astype(int)

        for (x1, y1, x2, y2), conf, cls_id in zip(boxes, confs, clss):
            x1, y1, x2, y2 = map(int, [x1, y1, x2, y2])
            color = class_colors[cls_id]
            cv2.rectangle(img_with_boxes, (x1, y1), (x2, y2), color, line_thick)
            label = f"{model.names[cls_id]} {conf:.2f}"
            cv2.putText(img_with_boxes, label, (x1, max(y1-10, 20)),
                        cv2.FONT_HERSHEY_SIMPLEX, font_scale, color, line_thick)

    # --- DISPLAY in Colab ---
    fig, axes = plt.subplots(1, 2, figsize=(14, 7))  # not too big for notebook
    axes[0].imshow(img)
    axes[0].set_title("Original Tile", fontsize=14)
    axes[0].axis("off")

    axes[1].imshow(img_with_boxes)
    axes[1].set_title("Detections (colored by class)", fontsize=14)
    axes[1].axis("off")

    # Add legend on the right
    legend_elements = [Patch(facecolor=np.array(class_colors[i])/255,
                             label=f'{model.names[i]} (Class {i})')
                       for i in range(num_classes)]
    fig.legend(handles=legend_elements, bbox_to_anchor=(1.02, 1),
               loc='upper left', fontsize=11)

    plt.tight_layout()

    if save_path:
        plt.savefig(save_path, bbox_inches='tight', dpi=200)  # good balance

    plt.show()

import glob

# Get all tiles in your tile directory
tile_paths = sorted(glob.glob("inference_tiles/*.png"))

# Previewing a subset
for i, tile_path in enumerate(tile_paths[:]):
    results = model.predict(
        source=tile_path,
        imgsz=1024,
        conf=0.25,
        verbose=False
    )
    preview_detections(tile_path, results)

# -----------------------
# 6. Convert predictions back to geo-coordinates
# -----------------------
            for r in results:
                boxes_xyxy = r.boxes.xyxy.cpu().numpy()
                cls = r.boxes.cls.cpu().numpy()
                conf = r.boxes.conf.cpu().numpy()

                for k, (x1, y1, x2, y2) in enumerate(boxes_xyxy):
                    global_x1 = x1 + x
                    global_y1 = y1 + y
                    global_x2 = x2 + x
                    global_y2 = y2 + y

                    # pixel -> geo
                    rowcol_to_coords = lambda px, py: rasterio.transform.xy(transform, py, px)
                    lon1, lat1 = rowcol_to_coords(global_x1, global_y1)
                    lon2, lat2 = rowcol_to_coords(global_x2, global_y2)

                    geom = box(lon1, lat2, lon2, lat1)

                    predictions.append({
                        "geometry": geom,
                        "class": int(cls[k]),
                        "confidence": float(conf[k])
                    })

# -----------------------
# 7. Export predictions as GeoJSON
# -----------------------
gdf = gpd.GeoDataFrame(predictions, crs=src.crs)
geojson_path = "predictions.geojson"
gdf.to_file(geojson_path, driver="GeoJSON")

print("✅ Predictions saved as:", geojson_path)
files.download(geojson_path)
